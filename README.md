# Использование SIMD инструкций для ускорения вычислений

# Первая попытка измерить

## Описание 

Цель проекта - посмотреть, как использование SIMD инструкций влияет на производительность программы. SIMD инструкции можно применять и в коде на ассемблере, и в коде на си. Для применения их в коде на си используются intrinsic-и - функции, вызов которых заменяется на ассемблерные инструкции компилятором и не требуют линковки с какой-либо библиотекой. 

В качестве алгоритма для применения intrinsic-ов было выбрано построение [множества Мандельброта](https://ru.wikipedia.org/wiki/Множество_Мандельброта), так как с точки зрения вычисления цвета каждой точки это достаточно затратный алгоритм и на нем будет заметно видна разница в производительности. 

Краткое описание алгоритма построения множества Мандельброта:

1. Выберем центр координат, мысленно нарисуем круг какого-то радиуса (в нашем случае 10) вокруг нее. 
2. Перебираем точки с различными координатами (x, y). Фиксируем точку (x0, y0) = (x, y), для нее применяем формулы:

$x := x^2 - y^2 + x_0$, \
$y := x \cdot y + x \cdot y + y_0$. 

Продолжаем рассчитывать, пока точка (x, y) не выйдет за грань выбранного нами круга. При расчете необходимо запоминать, за сколько итераций точка вышла из выделенной нами окружности. В зависимости от этого значения высчитывается цвет точки (x0, y0). К сожалению, точка может никогда не выйти за грань круга, для этого сверху есть ограничение в 255 итераций - после этого цикл принудительно прерывается.

3. Продолжаем перебирать точки и выполнять п.2.

Для лучшего понимания, как эти формулы применяются для построения стоит обратиться к [википедии](https://ru.wikipedia.org/wiki/Множество_Мандельброта).

Чтобы не было так скучно, все это визуализируется с помощью SFML. 

Было написано 3 программы:

1. Наивная реализация. Запуск с оптимизациями -O0 и -O3.
2. Программа с использованием AVX инструкций, запуск с оптимизацией -O3. 
3. Программа, в которой совершена попытка подтолкнуть компилятор увидеть возможность использовать SIMD инструкции. Для этого данные хранятся в массивах размера 8 (как вектора ymm), а над ними выполняются операции, как с векторами. В некотором смысле это контрольный эксперимент - проверяем, так ли необходимо использовать intrinsic-и в своем коде или достаточно просто помочь компилятору увидеть их.

Все программы запускаются с флагом "-mavx2", чтобы компилятор мог использовать AVX инструкции, если увидит возможность.

Получившееся изображение:

![mandelbrot](https://github.com/d3clane/Mandelbrot/blob/master/Readmeassets/imgs/mandelbrot.png)
 
Для замера времени используется код на [ассемблере](/Src/GetTimeStampCounter.s), который использует инструкцию `rdtsc` для подсчета количества циклов процессора, потраченных на расчет множества Мандельброта. Так как для сравнения производительности достаточно поделить друг на друга результаты при разных запусках,переводить это время в секунды не имеет смысла. Когда выполняются замеры, функция вывода изображения отключается, чтобы меньше приходилось ждать - выполняется много измерений, а затем высчитывается среднее время для большей точности. 

В каждой программе время, потраченное на расчет множества Мандельброта, рассчитывается в цикле 1000 раз, а затем усредняется.

## Установка и запуск

### Установка

```
git clone https://github.com/d3clane/Mandelbrot.git
cd Src && make buildDirs && make
```

Уровень оптимизации и необходимые define-ы изменять в переменной CXXFLAGS.

### Запуск

- Наивная реализация - ./build/bin/testNoAvx
- Реализация с AVX инструкциями - ./build/bin/testAvx
- Реализация на массивах - ./build/bin/testNoAvxArrays

## Наивная реализация

Характерное время работы программы во время измерений - около 4.5 минут для неоптимизированной версии и 2.5 для оптимизированной.

По реализации нечего сказать, посмотрим на измерения:

- -O0: 670635944 тактов процессора
- -O3: 379457887 тактов процессора

Ничего удивительного, компилятор с оптимизациями -O3 ускоряет в 1.77 раз.

## SIMD инструкции

Мой процессор поддерживает AVX и AVX2, то есть вектора размером в 256 бит или 32 байта. 

Относительно наивной реализации меняется только часть расчета цвета пикселей. Основная идея: наш цикл пробегается по координатам y, внутри по координатам x. Цвет для какой-то конкретной точки никак не зависит от результатов для остальных, при этом формулы для расчета не меняются, поэтому параллельно можно рассчитывать несколько точек. Для этого используются регистры ymm, которые способны хранить 32 байта и совершать операции параллельно. Так как я использую тип данных float, то ожидаемое ускорение - в 8 раз (32 байта / sizeof(float), где sizeof(float) = 4 байта). Алгоритм по шагам:

- Выделяю соседние 8 пикселей [x, x + 1, x + 2, ..., x + 7], записываем их координаты в переменную типа __m256
- Воспринимая каждую координату как float и используя то, что операции с ymm регистрами выполняются параллельно над каждым участком из X байт (X зависит от типа операции) мы можем параллельно пересчитывать 8 точек.
- Цикл продолжается, пока последняя точка из выбранного множества не выйдет за круг заданного радиуса(часть алгоритма построения множества Мандельброта). Так как это построение множества Мандельброта, не будем следить за тем, что какая-то точка может сначала выйти из круга, а затем вернуться, так как после выхода за границы она только отдаляется. Этот факт облегчает построения алгоритма. При этом для каждой точки надо зафиксировать, за сколько итераций она вышла за грани - этот момент рассмотрим поподробнее после перечисления действий алгоритма.
- После пересчета переменные типа m256 можно воспринимать как массивы данных, по которым будем итерироваться. Создаем указатели нужных типов и указываем ими на начало памяти, где лежат наши данные. Далее в простом цикле заполняем цвета для пикселей.

Теперь рассмотрим подробнее момент, как фиксируется количество итераций, после которых точка вылетела за границу круга. Рассмотрим подробно следующие строчки:

```
__m256 cmpRadius = _mm256_cmp_ps(radiusSquare, maxRadiusSquare, _CMP_LT_OQ);
numberOfIterations = _mm256_sub_epi32(numberOfIterations, _mm256_castps_si256(cmpRadius));
```

Что лежит в cmpRadius? Каждый полученный радиус сравнивается с максимальным и в каждой из 8 ячеек появляется одно из двух чисел:

- 0, если точка вышла за границы
- 0xFFFFFFFF, если точка лежит в границах

Заметим, что 0xFFFFFFFF можно интерпретировать, как -1. Тогда для каждой точки из уже подсчитанного количества итераций для нее достаточно вычесть cmpRadius, которое интерпретируется, как int значения(это делается с помощью инструкции `_mm256_casrps_si256(cmpRadius)`). Если точка внутри круга - вычитается (-1), то есть число итераций увеличивается на одну. Если точка вне круга - вычитается ноль, то есть ничего не происходит. Тогда количество итераций для каждой точки считается верно. 

Характерное время работы программы во время измерений - порядка 20 секунд.

Измеренное время с оптимизацией -O3:
- 51913873

Это в $\frac{379457887}{51913873} = 7.31$ раз быстрее, чем без avx инструкций. Почему выигрыш оказался не в 8 раз, а всего в 7.31? Мои предположения:
- Дополнительные инструкции - теперь необходимо считать mask, чтобы определить, нужно ли дальше продолжать цикл.
- Цикл продолжается, пока самая последняя точка не выйдет за границу круга. Это может оказываться довольно сильное влияние, так как значительную часть картинки занимают точки, которые бесконечно циклятся и ограничиваются сверху максимальным числом итераций.
- В конце цикла необходимо достать по отдельности различные значение из ymm регистра, это довольно трудоемкая задача. 
- Запись полученных значений в массив пикселей никак не ускорялась. 

## Оптимизация компилятором

Попробуем повторить полученный нами успех с использованием AVX инструкций, только в этот раз без их использования. AVX инструкции по сути своей - операции над векторами(массивами) размера 8, только они применяются одновременно ко всем значениям, а не последовательно, как это было бы в реализации на массивах. То есть, к примеру, intrinsic `_mm256_mul_ps(__m256 src1, __m256 src2)` можно реализовать так:

```
static inline void mm256_mul_ps(m256 dst, m256 src1, m256 src2)
{
    for (size_t i = 0; i < 8; ++i) dst[i] = src1[i] * src2[i];
}
```

Это будет в 8 раз медленнее, так как действия выполняются последовательно, но что если после приведения к такому виду, компилятор сможет заметить возможную оптимизацию с использованием AVX инструкций, и на выходе получится такой же оптимизированный код? Это я и хочу проверить.

Функции в данном примере названы по подобию с intrinsics-ами, в большинстве своем их реализации схожи с тем, что должны делать стандартные intrinsic-и, но в некоторых случаях для удобства были изменены аргументы функции или возвращаемый результат. 

Характерное время работы - порядка одной минуты.

Измеренное время с оптимизацией -O3 и использованием -mavx2:
- 147620484

Это в $\frac{379457887}{147620484} = 2.57$ раз быстрее, чем без использования массивов, но все еще медленнее, чем если бы были использованы intrinsic-и. То есть компилятор действительно смог заметить новые возможности для оптимизаций, но это все равно хуже, чем производительность, полученная с помощью непосредственного использования intrinsic-ов.

## Вывод

Использование intrinsic-ов может значительно повысить производительность программы. Подобный алгоритм повышения скорости работы программы можно использовать, когда заметно, что какие-то части вычислений могут выполняться параллельно друг с другом, нет зависимости по данным, но при этом алгоритм их вычисления одинаковый. В нашем случае оптимизировался расчет точек для получения цвета раскраски при построении множества Мандельброта - для каждой точки существовала конкретная неизменная формула для подсчета следующей точки и при этом не существовало зависимости по данным между результатами, полученными для точек с другими координатами и конкретно выбранной, поэтому ряд соседних точек был помещен в один регистр и затем над ними параллельно выполнялись идентичные действия.


# Работа над ошибками, допущенными в ходе измерений

## Несколько запусков программы

При измерении времени не гарантировалось, что нет запущенных фоновых процессов, влияющих на производительность программы, так как забирают вычислительные мощность на свои задачи. Причем эти процессы могут даже не зависеть от меня - например, что-то может выполняться операционной системой. Чтобы избежать этого можно запускать программу несколько раз. Тогда эти эффекты будут заметны, так как время для каждого запуска будет отличаться. После этого можно усреднить время с помощью метода наименьших квадратов. Запускать лучше от 3 до 5 раз, остановимся на трех разах, так как характерное время работы для неоптимизированной программы во время измерений порядка 5 минут, влияние фоновых процессов должно сглаживаться на таком промежутке времени.

## Измеряем не то

Четко обозначим, какую именно часть программы мы ускоряли и что мы хотим сравнить. Изменения происходят в функции расчета раскраски для множества Мандельброта. Конкретно в ней нас интересует часть, в которой применяются сами формулы для построения множества Мандельброта - тот кусок кода, в котором происходит непосредственно расчет количества итераций прежде, чем точка выйдет за границы круга. Что включается в эту часть? Инициализация необходимых переменных, внешних циклов по x, y, расчет по формулам. Получается, все это время в измерениях учитывалось время, затраченное на то, чтобы записывать цвета в массив. Очевидно, что эта часть никак не относится к тому, что ускорялось с помощью AVX инструкций, а значит ее не надо учитывать при измерении производительности программы. Теперь есть несколько вариантов учесть этот факт:
- Контрольный эксперимент. Убираю часть, отвечающую за расчет по формулам, и измеряю время. После этого полученное время можно вычесть из полученного ранее, так мы не будем учитывать в нашем итоговом результате время, потраченное на запись в массив пикселей. Здесь надо учесть возможные оптимизации компилятора, а также факт того, что в таком случае не учитывается в измерении время, потраченное на инициализацию переменных, внешних циклов. Для их измерения тоже можно проводить соответствующие контрольные эксперименты, остановиться стоит тогда, когда точность достаточно удовлетворительна.
- Можно измерять время, потраченное на запись в массив пикселей, а затем вычитать его. Здесь возникает проблема - для измерения этого времени необходимо два вызова функции `GetTimeStampCounter`, которая, собственно, проводит измерения. Выходит, что в наших измерениях будет учитываться время, потраченное на эти вызовы, причем оно может быть значительно, так как вызовов много. Можно попытаться измерить время, которое тратится на вызов функции GetTimeStampCounter, и вычесть его.
- При измерении времени мы отключали часть, которая отвечает за вывод изображения на экран. Здесь можем поступить также - отключим часть, которая пишет в массив пикселей, таким образом сможем избавиться от учета этой части кода в итоговом времени. Здесь может возникнуть проблема с оптимизирующим компилятором - заметив, что цикл просто пробегается, но никаких действий с полученными данными не выполняется, он может выкинуть его из программы. Рассмотрим этот вариант подробнее. 

Измерения подтверждают факт того, что компилятор просто выкидывает мой цикл - расчет выполняется за 47 тактов. Попробуем решить эту проблему - добавим volatile к переменной x, которая пересчитывается каждый раз в ходе использования формул построения множества Мандельброта. Измерим время на наивной реализации с оптимизацией -O3:

|                          |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк   |
|---                       |---          |---        |---        |---               |
|Наивная реализация -O3    | 472367113   | 460118996 | 477657889 | 4.7e8 +- 9e6     |

 
Время увеличилось, хоть и мы перестали записывать в массив пикселей - компилятор решил не применять какие-то оптимизации из-за ключевого слова volatile, а это не то, чего мы хотели добиться, значит этот вариант нам не подходит. Попробуем другой способ не дать компилятору удалить цикл - создадим переменную `allIterationsCounter`, которая накапливает в себе количество итераций, сделанных во время расчета точек, а затем будем выводить его после того, как посчитает итоговое время - так printf не будет влиять на измерения, но не даст компилятору удалить цикл, так как для подсчета числа итераций ему необходимо выполнить все действия. Аналогичный запуск теперь дает:

|                          |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк   |
|---                       |---          |---        |---        |---               |
|Наивная реализация -O3    | 354370425   | 370030305 | 362082959 | 3.622e8 +- 7.8e6 |

Возникает новая проблема - побочный эффект в виде постоянного прибавления к переменной каких-то значений - это же тоже какая-то операция, на которую тратится время. 

Необходимо оценить время, которое тратится на нашу новую операцию. Проведем два контрольных эксперимента - 
1. Программа, в которой к основному костяку программы (расчет множества Мандельброта) добавляется запись в массив пикселей.
2. Программа, в которой к основному костяку программы добавляется и запись в массив пикселей, и расчет новой переменной.

Сравнив эти два измерения сможем оценить, нужно ли учитывать вклад новой переменной во время работы - если оно в пределах погрешности, то это не имеет смысла. Проведем измерения сначала для наивной реализации: 

- Пиксели - измерения, когда в массив пикселей записываются результаты вычисления цвета.
- allIterationsCounter - измерения, когда рассчитывается вспомогательная переменная, мешающая оптимизациям компилятора.
- Пиксели и allIterationsCounter - измерения, когда и записывается в массив пикселей, и рассчитывается переменная.

|                               |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк   |
|---                            |---          |---        |---        |---               |
|Пиксели                        | 358323776   | 363895829 | 369108459 | 3.638e8 +- 5.4e6 |
|Пиксели и allIterationsCounter | 365261248   | 365202553 | 368862029 | 3.664e8 +- 2.1e6 |
|allIterationsCounter           | 354370425   | 370030305 | 362082959 | 3.622e8 +- 7.8e6 |

Видно, что для наивной реализации нет никакой разницы, учитывать или нет запись в массив пикселей / расчет новой переменной - все эти значения лежат в пределах погрешности от запуска к запуску.

При измерении времени для наивной реализации с оптимизацией -O0, волноваться о том, что компилятор выкинет цикл не нужно, поэтому можно просто запустить без каких-либо дополнительных переменных и померить: 

|                          |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк   |
|---                       |---          |---        |---        |---               |
|Наивная реализация -O0    | 695839254   | 788058821 | 753900824 | 7.46e8 +- 4.7e7  |

Подобные эксперименты теперь хочется провести вместе с версиями с SIMD инструкциями и реализацией через массивы.

Измерения для программы с AVX инструкциями:

|                               |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк    |
|---                            |---          |---        |---        |---                |
|Пиксели                        | 55395550    | 52678083  | 53521959  | 5.390e7 +- 1.4e6  |
|Пиксели и allIterationsCounter | 53582672    | 52717587  | 53162380  | 5.315e7 +- 4.3e5  |
|allIterationsCounter           | 50715669    | 51682496  | 50241135  | 5.088e7 +- 7.3e5  |

Здесь заметно, что непосредственно время, которое тратится на выполнение операций с allIterationsCounter лежит в пределах погрешности, то есть как-то учитывать его не имеет смысла. Тем не менее, операция записи в массив пикселей значительно влияет на измерения и избавление от этой части улучшает точность полученных данных. 

Наконец, проведем измерения для версии с массивами:

|                               |Запуск 1     |Запуск 2   |Запуск 3   | Среднее по мнк   |
|---                            |---          |---        |---        |---               |
|Пиксели                        | 150786411   | 147846997 | 152968431 | 1.505e8 +- 2.6e6 |
|Пиксели и allIterationsCounter | 150236275   | 152382926 | 149757699 | 1.508e8 +- 1.4e6 |
|allIterationsCounter           | 139342632   | 136071354 | 137999552 | 1.378e8 +- 1.6e6 |

Результаты интерпретируются так же, как и с AVX инструкциями.

## Сравнение итоговых результатов

Теперь, когда мы выяснили, какие допущения при измерениях можно делать, а какие нет, пришло время сравнить полученные результаты.

При использовании AVX инструкций выигрыш получается $\frac{3.622e8}{5.088e7} = 7.11 \pm 0.25$ раз. Это не совпадает с ожидаемым результатом в 8 раз. Причины почти те же, что и были в прошлый раз:
- Дополнительные инструкции - теперь необходимо считать mask, чтобы определить, нужно ли дальше продолжать цикл.
- Цикл продолжается, пока самая последняя точка не выйдет за границу круга. Это может оказывать довольно сильное влияние, так как значительную часть картинки занимают точки, которые бесконечно циклятся и ограничиваются сверху максимальным числом итераций.
- Накладные расходы на использование AVX инструкций.

При использовании версии на массивах выходит ускорение в $\frac{3.622e8}{1.378e8} = 2.62 \pm 0.09$. Проанализируем Как и говорилось, компилятор, предположительно, смог увидеть возможность использовать AVX инструкции, но по производительности все еще не догнал прямое использование intrinsic-ов.

## Выводы

Выводы остаются теми же, просто измерения стали точнее. 
